package problem1921;

public class Example3 {


    // ход Пети, результат отвечает на вопрос, выполняется ли первое
    // требование задачи,
    // l - кол-во камней в первой куче, r - во второй,  step - номер хода
    static boolean player1(int l, int r, int step) {
        // если это первый ход Пети, тогда Ваня пока что
        // не сделал ни одного хода
        if (step == 1) {
            // При любом ходе Пети Ваня должен победить,
            // поэтому используем И
            return player2(l + 1, r, step) &&
                    player2(l, r + 1, step) &&
                    player2(l * 2, r, step) &&
                    player2(l, r * 2, step);

        } else if (step == 2) { // если это второй ход Пети, т.е. Ваня сделал уже один ход
            // если Ваня при этом победил,
            if (l + r >= 77)
                // требование задачи выполнено
                return true;

            // При любом ходе Пети Ваня должен победить,
            // поэтому используем И
            return player2(l + 1, r, step) &&
                    player2(l, r + 1, step) &&
                    player2(l * 2, r, step) &&
                    player2(l, r * 2, step);
        } else { // если это третий ход Пети, т.е. Ваня сделал уже два хода
            // если Ваня при этом победил, то требование задачи не выполнено
            return l + r >= 77;
        }
    }

    // ход Вани, результат отвечает на вопрос, выполняется ли первое
    // требование задачи,
    // l - кол-во камней в первой куче, r - во второй,  step - номер хода
    static boolean player2(int l, int r, int step) {
        // обработка состояния игры после хода Пети
        // если Петя сделал первый ход
        if (step == 1) {
            // если он при этом победил,
            if (l + r >= 77)
                // требование задачи не выполнено
                return false;

            // разные ходы Вани
            // у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
            // или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
            return player1(l + 1, r, step + 1) ||
                    player1(l, r + 1, step + 1) ||
                    player1(l * 2, r, step + 1) ||
                    player1(l, r * 2, step + 1);
        } else { // если Петя сделал второй ход
            // если он при этом победил,
            if (l + r >= 77)
                // требование задачи не выполнено
                return false;

            // у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
            // или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
            return player1(l + 1, r, step + 1) ||
                    player1(l, r + 1, step + 1) ||
                    player1(l * 2, r, step + 1) ||
                    player1(l, r * 2, step + 1);
        }
    }


    // ход Пети, результат отвечает на вопрос, выполняется ли второе
    // требование задачи,
    // l - кол-во камней в первой куче, r - во второй,  step - номер хода
    static boolean checkPlayer1(int l, int r, int step) {
        if (step == 1) {
            // При любом ходе Пети Ваня не должен гарантированно победить,
            // поэтому отрицаем выражение и используем И
            return !(checkPlayer2(l + 1, r, step) &&
                    checkPlayer2(l, r + 1, step) &&
                    checkPlayer2(l * 2, r, step) &&
                    checkPlayer2(l, r * 2, step));
        } else { // если это второй ход Пети, т.е. Ваня сделал уже один ход
            // если он при этом победил, возвращаем, что условие выполнено
            return l + r >= 77;
        }
    }

    // ход Вани, результат отвечает на вопрос, выполняется ли второе
    // требование задачи
    // l - кол-во камней в первой куче, r - во второй,  step - номер хода
    static boolean checkPlayer2(int l, int r, int step) {
        // При любом ходе Пети Ваня должен победить,
        // поэтому используем И
        return checkPlayer1(l + 1, r, step + 1) ||
                checkPlayer1(l, r + 1, step + 1) ||
                checkPlayer1(l * 2, r, step + 1) ||
                checkPlayer1(l, r * 2, step + 1);
    }


    public static void main(String[] args) {
        // перебираем кол-во камней во второй куче
        for (int s = 0; s < 69; s++) {
            // запускаем обработку первого шага Пети, если
            // нас устраивает результат, проверки выполняем отдельными методами
            if (player1(7, s, 1) && checkPlayer1(7, s, 1)) {
                // выводим кол-во камней во второй куче
                System.out.println(s);

                break;
            }
        }
    }
}
